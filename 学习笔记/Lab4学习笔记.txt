一、系统调用
	API、系统调用层次结构
	用户程序User Program
	应用程序编程接口API/POSIX，C Standard Library，etc
	系统调用/read,write,fork,etc.
二、系统调用实现机制
	流程：
	1.调用一个封装好的用户空间的库函数（如writef）
	2.调用用户空间的syscall_*函数
	3.调用msyscall，用于陷入内核态
	4.陷入内核，内核取得信息，执行对应的内核空间的系统调用函数(sys_*)
	5.执行系统调用，并返回用户态，同时将返回值“传递”回用户态
	6.从库函数返回，回到用户程序调用处
	
	(user/syscall_lib.c)syscall开头的函数是我们在用户空间中最接近的内核的也是最原子的函数
		调用了msyscall函数，(user/syscall_wrap.S)，msyscall函数共有6个参数
		函数的第一个参数都是一个与调用名相似的宏（如SYS_putchar)----系统调用号
								-内核区分何种系统调用的唯一依据
		syscall开头的函数将msyscall函数前4个参数存入$a0-$a3寄存器里（寄存器传参）
		同时栈帧底部保留16字节的空间（不要求存入参数的值）
		后2个参数只会被存入前4的参数的预留空间之上的8字节空间内（无寄存器传参）
	sys开头的函数是内核中系统调用具体内容

	没有函数调用语句的函数称为叶函数
	有函数调用语句的函数称为非叶函数
	？？？
	/* TODO: 将系统调用号“复制”入寄存器$a0 */
		从哪？
	
	/* TODO: 在当前栈指针分配6 个参数的存储空间，并将6 个参数安置到期望的位置*/
		哪6个？
三、基础系统调用函数	

四、进程间通信机制（IPC）
	IPC的目的是使两个进程之间可以通讯
	IPC需要通过系统调用来实现
五、fork
	新的进程在开始运行时有着和旧进程绝大部分相同的信息
	新进程中fork有一个为0的返回值
	父进程（旧进程）中fork返回值是子进程的env_id >0 -----用于在使用fork后区分父子进程
六、写时复制机制
	父子进程使用的时相同的物理空间。
	子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，虽然两者虚拟空间不同，但是他们所对应的物理空间是同一个。
	当父子进程中有修改内存（一般是数据段）的行为发生时
	内核捕捉这种缺页中断
	为发生内存修改的进程相应的地址分配物理页面
	一般来说子进程的代码段继续共享父进程的物理空间（两者代码完全相同）
	――若fork后再子进程中执行了exec，子进程的代码段也会分配单独的物理空间
	对于所有可被写入的内存页面，都需要通过设置页表项标识位PTE_COW的方式保护起来
	父进程或子进程试图写一个被保护的物理页，就会产生一个异常（缺页中断）
七、fork返回值
	来自系统调用――syscall_env_alloc
	任务：创建进程、使用当前进程的一些信息作为模板来填充这个进程
		运行现场：复制Trapframe到子进程的进程控制块中
		程序计数器：子进程的程序计数器被设置为sys_env_alloc返回后的地址，也就是它陷入异常地址的下一行指令的地址
				（这个值保存在Trapframe)
		返回值有关：系统调用本身需要一个返回值（影响父进程），对于子进程需要对Trapframe进行修改
		进程状态：子进程再syscall_env_alloc返回后不能立即被加入调度队列
八、父进程与子进程
	父进程在子进程被唤醒前需要做一些准备
	遍历进程的大部分用户空间页，对于所有可以写入的页面的页表项，在父进程和子进程都加以PTE_COW标志位保护(duppage)
#define PTE_V           0x0200  // Valid bit
#define PTE_R              0x0400  // Dirty bit ,'0' means only read ,otherwise make interrupt
#define PTE_COW         0x0001  // Copy On Write
#define PTE_LIBRARY    0x0004  // share memmory
