一、管道
（一）、初窥管道
	典型的单向通信，又叫匿名管道
	只能在具有公共祖先的进程之间使用，通常使用在父子进程之间通信
	
	int pipe(int fd[2]); 成功返回0，否则返回-1；
	参数fd返回两个文件描述符，fd[0]对应读端，fd[1]对应写端

	管道在父子进程之间通信的基本用法：
		pipe函数之后，调用fork来产生一个子进程，之后在父子进程中执行不同的操作
		fork之后，进程在开始读或写管道之前都会关掉不会用到的管道端
	管道是一种只在内存中的文件
	在UNIX种使用pipe系统调用时，进程中会打开两个新的文件描述符
	一个只读端和只写端
	这两个文件描述符都映射到了同一片内存区域
	这样建立的管道的两端都在同一进程中，
	而且构建出的管道两端是两个匿名的文件描述符，让其他进程无法连接该管道
	在fork的配合下，才能在父子进程间建立起进程间通信管道
	这也是匿名管道只能在具有亲缘关系的进程间通信的原因

（二）、管道的测试
		
（三）、管道的读写
	user/pipe.c
	Pipe结构体
	p_rpos  下一个将要从管道读的数据的位置  只有读者可以更新
	p_wpos 下一个将要向管道写的数据的位置  只有写者可以更新
	p_buf[BY2PIPE] 一个短道有BY2PIPE(32Byte)大小的缓冲区
	
	读者与写者通过p_rpos与p_wpos这两个变量的值进行协调读写
	p_buf缓冲区发挥的作用类似于环形缓冲区，下一个要读或写的位置i实际上是i%BY2PIPE
	
	***读者在从管道读取数据时，将p_buf[p_rpos%BY2PIPE]的数据拷贝走，然后读指针自增1
	******应注意的是，管道的缓冲区此时可能还没有被写入数据
	    若管道数据为空，即当p_rpos >= p_wpos时，应将进程切换到写者运行
	***写者在向管道写入数据时，也是将数据存入p_buf[p_wpos%BY2PIPE],然后写指针自增1
	******需要注意，管道的缓冲区可能出现满溢的情况，
	******所以写者必须得再p_wpos - p_rpos < BY2PIPE时方可运行，否则要一直挂起
	
	
	
		


	

